3.3. THIẾT KẾ KIẾN TRÚC HỆ THỐNG
3.3.1. Tổng quan kiến trúc Hybrid
Hệ thống sử dụng kiến trúc Hybrid kết hợp Modular Monolith cho ứng dụng chính và tách riêng Form Engine thành Microservice. Toàn bộ được đóng gói trong 5 Docker container và triển khai bằng Docker Compose.
Lý do chọn kiến trúc Hybrid là cân bằng giữa đơn giản và linh hoạt. Modular Monolith giúp phát triển nhanh với một codebase duy nhất, trong khi việc tách Form Engine cho phép mở rộng riêng phần xử lý nặng mà không ảnh hưởng đến phần còn lại.
Nếu dùng kiến trúc thuần Monolithic, khi Form Engine tạo PDF bị chậm hoặc treo sẽ kéo chậm toàn bộ hệ thống. Nếu dùng thuần Microservices, độ phức tạp vận hành sẽ quá lớn cho một đồ án tốt nghiệp.
3.3.2. Kiến trúc Backend với NestJS
Backend được xây dựng với NestJS framework và chia thành 23 module độc lập. Các module chính bao gồm Auth xử lý xác thực và làm mới token, Users quản lý người dùng, Faculties quản lý đơn vị, Proposals quản lý đề tài, Workflow xử lý máy trạng thái, RBAC phân quyền ba chiều, và Audit ghi log kiểm toán.
Lý do chia thành nhiều module là tuân theo nguyên tắc Single Responsibility. Mỗi module chỉ làm một việc và có thể phát triển, test độc lập. Khi cần sửa logic phân quyền, chỉ cần sửa module RBAC mà không ảnh hưởng đến module khác.
Nếu không chia module mà để tất cả code chung một nơi, theo thời gian code sẽ thành một khối lớn khó hiểu, khó sửa, và nhiều người không thể làm việc đồng thời trên cùng một phần.
3.3.3. Kiến trúc Frontend với React
Frontend sử dụng React 18 với TypeScript, Vite làm build tool, TanStack Query quản lý state server, và Tailwind CSS cho styling. Cấu trúc thư mục theo feature-based, mỗi tính năng có folder riêng chứa components, hooks, và types.
Lý do dùng TanStack Query là tự động quản lý việc fetch, cache, và làm mới dữ liệu từ server. Không cần viết thủ công các logic như kiểm tra dữ liệu đã cũ chưa, khi nào cần fetch lại, hoặc xử lý loading state.
Nếu không dùng thư viện quản lý state server, phải viết rất nhiều code boilerplate cho mỗi API call, dễ quên xử lý các edge case như loading, error, hoặc stale data.
Lý do dùng Tailwind CSS là viết style trực tiếp trong component mà không cần tạo file CSS riêng. Điều này giúp code gọn hơn và tránh vấn đề CSS bị xung đột tên class.
3.3.4. Kiến trúc Form Engine
Form Engine là microservice Python chạy độc lập, sử dụng FastAPI framework. Nhiệm vụ chính là nhận dữ liệu từ backend, điền vào template Word, và chuyển đổi sang PDF bằng LibreOffice headless.
Lý do tách Form Engine là việc chuyển đổi PDF tiêu tốn nhiều CPU và có thể mất 10 đến 15 giây. Nếu để chung với backend NestJS, khi có nhiều yêu cầu tạo PDF cùng lúc, toàn bộ API sẽ bị chậm.
Lý do dùng Python thay vì Node.js là thư viện python-docx xử lý file Word tốt hơn nhiều so với các thư viện Node.js tương đương. Việc tích hợp LibreOffice cũng dễ dàng hơn trong Python.
Nếu Form Engine bị lỗi hoặc quá tải, hệ thống chính vẫn hoạt động bình thường. Người dùng vẫn có thể làm việc với đề tài, chỉ là tạm thời không tạo được tài liệu.
3.3.5. Giao tiếp giữa các thành phần
Frontend gọi Backend qua REST API với 67 endpoint, sử dụng JWT token để xác thực mỗi request. Backend gọi Form Engine qua HTTP nội bộ trong Docker network để tạo tài liệu.
Lý do dùng REST API là đơn giản và phổ biến. Mọi lập trình viên đều quen thuộc với REST, dễ debug bằng công cụ như Postman, và dễ tích hợp với bất kỳ client nào.
Lý do không dùng GraphQL là quy mô dự án không cần thiết. GraphQL phù hợp khi có nhiều client với nhu cầu dữ liệu khác nhau. Với một ứng dụng web duy nhất, REST đủ đáp ứng và đơn giản hơn nhiều.
3.3.6. Kiến trúc triển khai với Docker
Hệ thống được đóng gói thành 5 container Docker bao gồm backend NestJS, frontend React được serve bởi Nginx, PostgreSQL database, Redis cache, và Form Engine Python. Nginx đóng vai trò reverse proxy định tuyến request đến container phù hợp.
Lý do dùng Docker là đảm bảo môi trường nhất quán từ máy phát triển đến server sản xuất. Không còn tình trạng chạy được trên máy tôi mà không chạy được trên máy bạn vì khác phiên bản thư viện.
Lý do dùng Docker Compose là quản lý nhiều container một cách dễ dàng. Chỉ cần một lệnh docker-compose up là khởi động toàn bộ hệ thống với đúng cấu hình mạng và volume.
Nếu không dùng Docker, việc cài đặt hệ thống trên server mới sẽ rất phức tạp, phải cài từng thành phần riêng lẻ và cấu hình thủ công.
3.3.7. Kiến trúc cache với Redis
Redis được sử dụng để cache các dữ liệu hay truy cập như danh sách quyền của người dùng, cấu hình hệ thống, và kết quả các truy vấn phức tạp. Cache có thời gian sống TTL và tự động xóa khi dữ liệu gốc thay đổi.
Lý do cần cache là giảm tải cho database và tăng tốc phản hồi. Việc kiểm tra quyền xảy ra ở mọi API call. Nếu mỗi lần đều truy vấn database, hệ thống sẽ chậm không chấp nhận được.
Lý do chọn Redis là hiệu năng cao với khả năng xử lý hàng triệu request mỗi giây, hỗ trợ nhiều cấu trúc dữ liệu, và có cơ chế hết hạn tự động.
Nếu không có cache, mỗi request sẽ tạo áp lực lên database. Khi có nhiều người dùng đồng thời, database sẽ bị nghẽn và toàn bộ hệ thống bị chậm.
