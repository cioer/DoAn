3.4. THIẾT KẾ CƠ SỞ DỮ LIỆU
3.4.1. Lựa chọn hệ quản trị cơ sở dữ liệu
Hệ thống sử dụng PostgreSQL 15 làm cơ sở dữ liệu chính. PostgreSQL là hệ quản trị cơ sở dữ liệu quan hệ mã nguồn mở với độ tin cậy cao và hỗ trợ đầy đủ tính năng.
Lý do chọn PostgreSQL thay vì MySQL là PostgreSQL có hỗ trợ tốt hơn cho các kiểu dữ liệu phức tạp như JSON, ARRAY, và ENUM. Việc xử lý transaction và khóa ngoại cũng đáng tin cậy hơn.
Lý do không dùng NoSQL như MongoDB là dữ liệu trong hệ thống có quan hệ chặt chẽ với nhau. Đề tài thuộc về Khoa, Khoa thuộc về Trường, người dùng có nhiều vai trò. Cơ sở dữ liệu quan hệ phù hợp hơn cho loại dữ liệu này.
3.4.2. Thiết kế bảng chính
Cơ sở dữ liệu gồm 21 bảng chính được chia thành các nhóm theo chức năng.
Nhóm người dùng và phân quyền gồm bảng users lưu thông tin người dùng, bảng roles lưu các vai trò, bảng permissions lưu các quyền, bảng role_permissions ánh xạ vai trò với quyền, và bảng user_roles ánh xạ người dùng với vai trò trong phạm vi đơn vị.
Nhóm tổ chức gồm bảng faculties lưu thông tin các Khoa và đơn vị trong trường.
Nhóm đề tài và workflow gồm bảng proposals lưu thông tin đề tài nghiên cứu, bảng proposal_members lưu thành viên tham gia đề tài, bảng workflow_logs ghi lại mọi chuyển đổi trạng thái, và bảng workflow_sla_tracking theo dõi thời hạn xử lý.
Nhóm Hội đồng và đánh giá gồm bảng councils lưu thông tin Hội đồng, bảng council_members lưu thành viên Hội đồng, bảng evaluations lưu phiếu đánh giá, và bảng evaluation_criteria lưu các tiêu chí đánh giá.
Nhóm tài liệu gồm bảng attachments lưu file đính kèm, bảng document_templates lưu mẫu biểu mẫu Word, và bảng generated_documents lưu tài liệu đã tạo.
3.4.3. Thiết kế bảng proposals
Bảng proposals là bảng trung tâm của hệ thống với các trường quan trọng như id là khóa chính UUID, title là tiêu đề đề tài, status là trạng thái hiện tại trong 15 trạng thái, faculty_id là khóa ngoại đến Khoa sở hữu, owner_id là khóa ngoại đến người tạo, current_handler_id là người đang xử lý, và form_data lưu dữ liệu biểu mẫu dạng JSON.
Lý do dùng UUID thay vì số tự tăng là tránh lộ thông tin về số lượng đề tài. Với số tự tăng, ai cũng biết đề tài có id là 100 thì hệ thống có khoảng 100 đề tài. UUID ngẫu nhiên không tiết lộ thông tin này.
Lý do lưu form_data dạng JSON là biểu mẫu có thể thay đổi theo thời gian. Nếu tạo cột riêng cho mỗi trường biểu mẫu, khi thêm trường mới phải sửa schema database. Với JSON, chỉ cần cập nhật template mà không cần thay đổi database.
3.4.4. Thiết kế bảng workflow_logs
Bảng workflow_logs lưu lịch sử mọi thay đổi trạng thái với các trường proposal_id là đề tài liên quan, action là hành động thực hiện như submit hoặc approve, from_state là trạng thái trước, to_state là trạng thái sau, performed_by là người thực hiện, performed_at là thời điểm, và reason là lý do nếu có.
Lý do bảng này chỉ cho phép thêm mới mà không được sửa hoặc xóa là đảm bảo tính toàn vẹn của lịch sử. Khi có tranh chấp hoặc thanh tra, dữ liệu này là bằng chứng không thể chối cãi.
Lý do lưu cả from_state và to_state thay vì chỉ to_state là có thể xây dựng lại toàn bộ lịch sử trạng thái từ đầu. Nếu chỉ lưu to_state, không biết đề tài đã ở trạng thái nào trước đó.
Nếu không có bảng này, khi thanh tra hỏi đề tài này được ai duyệt khi nào thì không có dữ liệu để trả lời.
3.4.5. Thiết kế bảng user_roles
Bảng user_roles khác biệt với các hệ thống thông thường vì có thêm trường faculty_id để xác định phạm vi vai trò. Các trường gồm user_id là người dùng, role_id là vai trò, và faculty_id là đơn vị áp dụng vai trò.
Lý do cần faculty_id là một người có thể có vai trò khác nhau ở các Khoa khác nhau. Ví dụ, một giảng viên có thể là Trưởng Khoa ở Khoa A nhưng chỉ là giảng viên bình thường ở Khoa B nếu kiêm nhiệm.
Nếu không có phạm vi đơn vị, việc phân quyền sẽ là toàn cục. Ai là Trưởng Khoa thì là Trưởng Khoa của tất cả các Khoa, điều này không đúng thực tế.
3.4.6. Thiết kế index và tối ưu truy vấn
Các index được tạo trên các trường hay được tìm kiếm như proposals.status, proposals.faculty_id, workflow_logs.proposal_id, và user_roles kết hợp cả ba trường.
Lý do cần index trên status là hầu hết các truy vấn đều lọc theo trạng thái. Ví dụ, lấy danh sách đề tài chờ duyệt Khoa. Không có index, database phải quét toàn bộ bảng.
Lý do cần index composite trên user_roles là truy vấn kiểm tra quyền luôn cần cả ba thông tin cùng lúc. Index composite giúp truy vấn này cực kỳ nhanh.
Nếu không có index phù hợp, khi bảng lớn lên hàng chục nghìn bản ghi, các truy vấn sẽ chậm dần và có thể mất vài giây thay vì vài mili giây.
3.4.7. Quản lý migration với Prisma
Prisma ORM được sử dụng để quản lý schema và migration database. Mỗi thay đổi cấu trúc được ghi lại thành file migration với timestamp, có thể áp dụng hoặc hoàn tác.
Lý do cần migration là theo dõi lịch sử thay đổi database một cách có hệ thống. Khi triển khai lên server mới, chỉ cần chạy các migration theo thứ tự để có database với cấu trúc đúng.
Lý do chọn Prisma là tự động sinh ra TypeScript types từ schema, đảm bảo code và database luôn đồng bộ. Khi thay đổi schema, TypeScript compiler sẽ báo lỗi ở tất cả các vị trí cần cập nhật.
Nếu không dùng migration mà sửa database bằng tay, không có cách nào biết database ở các môi trường khác nhau có giống nhau không, và không thể quay lại phiên bản trước khi có lỗi.
